<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PigMap.org - Leaflet Version</title>
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.bunny.net">
  <link href="https://fonts.bunny.net/css?family=chocolate-classical-sans:400|climate-crisis:400" rel="stylesheet">
  
  <!-- Leaflet CSS and JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Leaflet Control Geocoder for Nominatim Search -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  
  <style>
    :root {
      --primary-green: #4a8f5c;
      --primary-green-lighter: #c8e6d0;
      --dark-green: #2e7d32;
      --light-green: #bff4cd;
      --primary-red: #c62828;
      --light-red: #ff5f52;
      --dark-red: #8e0000;
      --text-light: #f5f5f5;
      --text-dark: #212121;
      --text-color: #212121;
      --background-light: #f8f9fa;
      --background-dark: #333;
      --border-color: #ddd;
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: 'Chocolate Classical Sans', system-ui, sans-serif;
      background-color: var(--background-light);
      color: var(--text-dark);
    }
    
    #map {
      height: 100vh;
      width: 100vw;
    }
    
    .header {
      position: absolute;
      top: 10px;
      left: 60px;
      z-index: 1000;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      max-width: 300px;
    }
    
    /* Ensure header doesn't overlap with map controls */
    /* Ensure header doesn't overlap with map controls */
    .leaflet-control-container .leaflet-top.leaflet-left {
      top: 70px; /* Give space for header */
    }
    
    /* Custom positioning for search control */
    .leaflet-control-geocoder {
      margin-top: 10px !important;
      clear: both;
    }
    
    .header h1 {
      margin: 0;
      font-family: 'Climate Crisis', display;
      font-size: 1.5rem;
      color: var(--primary-green);
    }
    
    .controls {
      position: absolute;
      bottom: 25px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .btn {
      background-color: var(--primary-green);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Chocolate Classical Sans', system-ui, sans-serif;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:hover {
      background-color: var(--dark-green);
    }
    
    /* Language switcher styles */
    .language-switcher {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001; /* Higher than other controls */
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .language-switcher select {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }
    
    /* Icon selector styles */
    .icon-select-container {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
    }
    
    .icon-preview {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      padding: 5px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }
    
    .icon-option {
      width: 32px;
      height: 32px;
      padding: 3px;
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .icon-option:hover {
      background-color: #f0f0f0;
    }
    
    .icon-option img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .icon-option.selected {
      border-color: var(--primary-green);
      background-color: rgba(74, 143, 92, 0.1);
    }
    
    .report-form {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 2000;
      width: 300px;
      max-width: 90vw;
      display: none;
    }
    
    .report-form h2 {
      margin-top: 0;
      color: var(--primary-green);
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input, .form-group select, .form-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: 'Chocolate Classical Sans', system-ui, sans-serif;
    }
    
    .form-actions {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    
    .popup-content {
      font-family: 'Chocolate Classical Sans', system-ui, sans-serif;
    }
    
    .popup-content h3 {
      margin: 0 0 10px 0;
      color: var(--primary-green);
    }
    
    .popup-content .meta {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 10px;
    }
    
    .popup-content img {
      max-width: 100%;
      margin-top: 10px;
      border-radius: 4px;
    }
    
    .location-details {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 5px;
    }
    
    .coordinates {
      display: inline-block;
      font-size: 0.8rem;
      color: #666;
    }
    
    .btn-small {
      padding: 5px 8px;
      font-size: 0.8rem;
    }
    
    /* Comment section styles */
    .comments-section {
      margin-top: 15px;
      border-top: 1px solid var(--border-color);
      padding-top: 10px;
    }
    
    .comment-item {
      padding: 8px;
      background-color: #f9f9f9;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    
    .comment-meta {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 4px;
    }
    
    .comment-form {
      margin-top: 10px;
    }
    
    .comment-form textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 8px;
      font-family: 'Chocolate Classical Sans', system-ui, sans-serif;
      resize: vertical;
    }
    
    .comment-form .media-upload {
      margin-bottom: 8px;
    }
    
    /* Category description style */
    .category-description {
      display: block;
      font-size: 0.8rem;
      color: #666;
      margin-top: 3px;
      font-style: italic;
    }
    
    /* Resources modal styles */
    .resource-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 10px;
    }
    
    .resource-item {
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 15px;
    }
    
    .resource-item h4 {
      margin: 0 0 8px 0;
      color: var(--primary-green);
    }
    
    .resource-item p {
      margin: 0 0 10px 0;
      font-size: 0.9rem;
    }
    
    .resource-link {
      display: inline-block;
      padding: 5px 10px;
      background-color: var(--light-green);
      color: var(--dark-green);
      text-decoration: none;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .resource-link:hover {
      background-color: var(--primary-green);
      color: white;
    }
    
    /* About section tabs */
    .tab-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .tab-navigation {
      display: flex;
      border-bottom: 1px solid var(--border-color);
    }
    
    .tab-button {
      padding: 8px 15px;
      background: none;
      border: none;
      cursor: pointer;
      font-family: inherit;
      border-bottom: 3px solid transparent;
    }
    
    .tab-button.active {
      border-bottom-color: var(--primary-green);
      color: var(--primary-green);
      font-weight: bold;
    }
    
    .tab-content {
      display: none;
      padding: 10px 0;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Modal blockquote style */
    blockquote {
      margin: 15px 0;
      padding: 10px 15px;
      border-left: 3px solid var(--primary-green);
      background-color: rgba(191, 244, 205, 0.2);
      font-style: italic;
    }
    
    /* Privacy notification */
    #notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .notification {
      background-color: rgba(255, 255, 255, 0.9);
      color: var(--text-dark);
      padding: 12px 15px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      max-width: 300px;
      border-left: 4px solid var(--primary-green);
      animation: slideIn 0.3s ease-out forwards;
    }
    
    .notification.error {
      border-left-color: var(--primary-red);
    }
    
    .notification.warning {
      border-left-color: #FFC107;
    }
    
    .notification.hide {
      animation: slideOut 0.3s ease-in forwards;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    
    /* Custom map controls styles */
    .custom-map-control {
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65);
      cursor: pointer;
      margin-bottom: 10px;
    }

    .custom-map-control a {
      display: block;
      text-align: center;
      text-decoration: none;
      color: black;
      width: 30px;
      height: 30px;
      line-height: 30px;
      font-size: 18px;
      font-weight: bold;
    }

    .custom-map-control a:hover {
      background-color: #f4f4f4;
    }

    /* Resources list in the About modal */
    .resource-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 15px 0;
    }

    .resource-button {
      display: block;
      background: var(--primary-green-lighter);
      color: var(--text-color);
      border: 1px solid var(--primary-green);
      padding: 10px 15px;
      text-align: left;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .resource-button:hover {
      background: var(--primary-green);
      color: white;
    }

    .about-modal-content {
      max-width: 600px;
    }

    .resource-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .resource-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .resource-modal-header h2 {
      margin: 0;
      font-size: 1.5rem;
    }

    .close-modal {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-color);
    }

    .resource-modal-body {
      padding: 20px;
      max-height: 70vh;
      overflow-y: auto;
      background: white;
      color: black;
    }

    @media (prefers-color-scheme: dark) {
      .resource-modal-body {
        background: #222;
        color: #f0f0f0;
      }
    }

    /* Dark mode implementation */
    .dark-mode {
      --text-color: #f0f0f0;
      --background-light: #222;
      --border-color: #444;
      --primary-green-lighter: #2a4e33;
    }

    /* Apply dark mode to body and map elements */
    body.dark-mode {
      background-color: var(--background-dark);
      color: var(--text-color);
    }

    body.dark-mode .header,
    body.dark-mode .language-switcher,
    body.dark-mode .report-form,
    body.dark-mode .notification,
    body.dark-mode .custom-map-control a,
    body.dark-mode .leaflet-control-geocoder-form input {
      background-color: #333;
      color: #f0f0f0;
    }

    body.dark-mode .comment-item {
      background-color: #3a3a3a;
    }

    body.dark-mode .resource-modal-body {
      background: #222;
      color: #f0f0f0;
    }

    body.dark-mode .icon-option:hover {
      background-color: #444;
    }

    body.dark-mode .comment-meta,
    body.dark-mode .coordinates,
    body.dark-mode .category-description {
      color: #aaa;
    }

    body.dark-mode select,
    body.dark-mode input,
    body.dark-mode textarea {
      background-color: #444;
      color: #f0f0f0;
      border-color: #555;
    }

    /* Dark mode toggle button */
    .dark-mode-toggle {
      position: absolute;
      top: 10px;
      right: 140px;
      z-index: 1001;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    body.dark-mode .dark-mode-toggle {
      background-color: #333;
      color: #f0f0f0;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>PigMap.org</h1>
  </div>
  
  <div id="map"></div>
  
  <div class="dark-mode-toggle">
    <span id="dark-mode-icon">🌙</span>
    <span id="dark-mode-label">Dark Mode</span>
  </div>
  
  <div class="controls">
    <button id="report-btn" class="btn">Report Location</button>
    <button id="locate-btn" class="btn">Find My Location</button>
  </div>
  
  <div id="report-form" class="report-form">
    <h2>Report Location</h2>
    <form id="submit-report">
      <div class="form-group">
        <label for="type">Type:</label>
        <select id="type" required>
          <!-- Categories will be loaded dynamically -->
        </select>
        <small class="category-description" id="category-description"></small>
      </div>
      <div class="form-group">
        <label for="count">How many?</label>
        <input type="number" id="count" min="1" value="1">
      </div>
      <div class="form-group">
        <label for="comment">Comments:</label>
        <textarea id="comment" rows="3"></textarea>
      </div>
      <div class="form-group">
        <label for="location">Location:</label>
        <input type="text" id="location" readonly>
        <div class="location-details" id="location-details">
          <small class="coordinates">Lat: <span id="lat-display">--</span>, Lng: <span id="lng-display">--</span></small>
          <button type="button" id="update-location-btn" class="btn btn-small">Update Location</button>
        </div>
      </div>
      <div class="form-group">
        <label for="media">Photo/Video (optional):</label>
        <input type="file" id="media" accept="image/*,video/*">
      </div>
      <div class="form-group">
        <label for="icon">Icon:</label>
        <div class="icon-select-container">
          <select id="icon" class="icon-select">
            <!-- Icons will be loaded dynamically -->
          </select>
          <div class="icon-preview" id="icon-preview">
            <!-- Icon previews will be displayed here -->
          </div>
        </div>
      </div>
      <div class="form-actions">
        <button type="button" id="cancel-btn" class="btn cancel-btn">Cancel</button>
        <button type="submit" class="btn">Submit</button>
      </div>
    </form>
  </div>

  <div class="language-switcher">
    <label for="language-select">Language:</label>
    <select id="language-select">
      <option value="en">English</option>
      <option value="es">Español</option>
      <option value="fr">Français</option>
      <option value="de">Deutsch</option>
      <option value="zh">中文</option>
    </select>
  </div>

  <script>
    // Categories with dual meanings for reports
    const reportCategories = [
      { id: "feral", label: "Feral Hog", description: "Wild/feral hog sighting", icon: "local_police_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "patrol", label: "Territory Patrol", description: "Regular movement patterns", icon: "radar_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "tracking", label: "Tracking Activity", description: "Evidence of surveillance", icon: "visibility_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "equipment", label: "Equipment Sighting", description: "Specialized gear or vehicles", icon: "front_loader_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "checkpoint", label: "Fixed Location", description: "Stationary presence", icon: "not_listed_location_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "damage", label: "Property Impact", description: "Damage to property or land", icon: "destruction_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "group", label: "Group Activity", description: "Multiple subjects working together", icon: "groups_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" },
      { id: "nighttime", label: "Night Activity", description: "Activity during darkness", icon: "nights_stay_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png" }
    ];
    
    // Initialize map
    const map = L.map('map').setView([39.8283, -98.5795], 5);
    
    // Define base map layers
    const baseMaps = {
      // Standard OpenStreetMap
      "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
      }),
      
      // OpenStreetMap multilingual (with local names)
      "OpenStreetMap Localized": L.tileLayer('https://{s}.tile.openstreetmap.de/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }),
      
      // USGS Topo
      "USGS Topographic": L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'USGS',
        maxZoom: 16
      }),
      
      // Stamen Terrain
      "Terrain": L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }),
      
      // Night Earth view (NASA)
      "Night Earth": L.tileLayer('https://map1.vis.earthdata.nasa.gov/wmts-webmerc/VIIRS_CityLights_2012/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}', {
        attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System (<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
        maxZoom: 8,
        time: '',
        tilematrixset: 'GoogleMapsCompatible_Level',
        format: 'jpg'
      }),
      
      // Satellite (ESRI)
      "Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 18
      })
    };
    
    // Add default map layer
    baseMaps["OpenStreetMap"].addTo(map);
    
    // Add layer control
    L.control.layers(baseMaps, {}, {position: 'bottomleft'}).addTo(map);
    
    // Add Nominatim search control
    const geocoder = L.Control.geocoder({
      defaultMarkGeocode: false,
      position: 'topright',
      placeholder: 'Search for a location...',
      errorMessage: 'Nothing found.',
      geocoder: L.Control.Geocoder.nominatim({
        geocodingQueryParams: {
          countrycodes: 'us', // Limit to US
          limit: 5
        }
      })
    }).addTo(map);
    
    // Create custom About/Info control
    const AboutControl = L.Control.extend({
      options: {
        position: 'topright'
      },
      
      onAdd: function(map) {
        const container = L.DomUtil.create('div', 'custom-map-control about-control leaflet-bar');
        const link = L.DomUtil.create('a', '', container);
        link.href = '#';
        link.title = 'About & Resources';
        link.innerHTML = 'ℹ️';
        
        L.DomEvent.on(link, 'click', L.DomEvent.stopPropagation)
          .on(link, 'click', L.DomEvent.preventDefault)
          .on(link, 'click', function() {
            showAboutModal();
          });
          
        return container;
      }
    });
    
    // Add the custom About control to the map
    map.addControl(new AboutControl());
    
    // Function to show the About modal with project information and resources
    function showAboutModal() {
      const modalContent = document.createElement('div');
      modalContent.className = 'about-modal-content';
      modalContent.innerHTML = `
        <h2>About PigMap.org</h2>
        <p>PigMap.org is a community-driven platform for tracking and reporting wildlife observations across the United States. Our goal is to help communities document and understand animal populations while protecting users' privacy.</p>
        
        <h3>Features</h3>
        <ul>
          <li>Private, anonymous reporting - no personal data is stored</li>
          <li>Multi-language support</li>
          <li>Detailed category system for accurate reporting</li>
          <li>Community comment system for ongoing observations</li>
        </ul>
        
        <h3>Privacy Commitment</h3>
        <p>Your privacy is our top priority. We do not collect IP addresses or any personally identifiable information. All reports are anonymous, and uploaded images are automatically stripped of metadata.</p>
        
        <h3>Educational Resources</h3>
        <p>Learn more about important topics related to wildlife management and conservation:</p>
        
        <div class="resource-list">
          <button class="resource-button" data-resource="fourth_amendment">Property Rights & Wildlife Management</button>
          <button class="resource-button" data-resource="first_amendment">Documentation Rights for Wildlife Management</button>
          <button class="resource-button" data-resource="due_process">Legal Frameworks for Rural Community Protection</button>
        </div>
      `;
      
      const modal = document.createElement('div');
      modal.className = 'resource-modal';
      modal.innerHTML = `
        <div class="resource-modal-body"></div>
      `;
      
      modal.querySelector('.resource-modal-body').appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Add event listeners to resource buttons
      modal.querySelectorAll('.resource-button').forEach(button => {
        button.addEventListener('click', () => {
          const resourceId = button.getAttribute('data-resource');
          document.body.removeChild(modal);
          showResourceDocument(resourceId);
        });
      });
      
      // Close modal when clicking outside content
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
      
      // Add escape key handler
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          document.body.removeChild(modal);
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }
    
    geocoder.on('markgeocode', function(e) {
      const bbox = e.geocode.bbox;
      const center = e.geocode.center;
      
      // Create temporary polygon to show search area
      const poly = L.polygon([
        bbox.getSouthEast(),
        bbox.getNorthEast(),
        bbox.getNorthWest(),
        bbox.getSouthWest()
      ]).addTo(map);
      
      map.fitBounds(poly.getBounds());
      
      // Remove the polygon after a delay
      setTimeout(() => poly.remove(), 2000);
      
      // If the report form is open, update the location
      if (reportForm.style.display === 'block') {
        updateReportLocation(center, e.geocode.name);
      }
    });
    
    // Create a layer group for reports
    const reportsLayer = L.layerGroup().addTo(map);
    
    // Form elements
    const reportForm = document.getElementById('report-form');
    const reportBtn = document.getElementById('report-btn');
    const locateBtn = document.getElementById('locate-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const submitForm = document.getElementById('submit-report');
    const iconSelect = document.getElementById('icon');
    const iconPreview = document.getElementById('icon-preview');
    const locationInput = document.getElementById('location');
    const latDisplay = document.getElementById('lat-display');
    const lngDisplay = document.getElementById('lng-display');
    const updateLocationBtn = document.getElementById('update-location-btn');
    
    // Current position marker and temporary markers
    let currentPositionMarker = null;
    let accuracyCircle = null;
    let tempMarker = null;
    let reportPosition = null;
    let locationAddress = null;
    
    // Show report form
    reportBtn.addEventListener('click', () => {
      reportForm.style.display = 'block';
      
      // Use current map center as default position
      const center = map.getCenter();
      updateReportLocation(center);
      
      // If the user clicks on the map while the form is open, update the location
      map.once('click', (e) => {
        updateReportLocation(e.latlng);
      });
    });
    
    // Update location button
    updateLocationBtn.addEventListener('click', () => {
      // Hide the form temporarily to see the map
      reportForm.style.display = 'none';
      
      // Show a message to click on the map
      alert('Click on the map to set the report location');
      
      // Once the user clicks on the map, update the location and show the form again
      map.once('click', (e) => {
        updateReportLocation(e.latlng);
        reportForm.style.display = 'block';
      });
    });
    
    // Function to update report location display
    function updateReportLocation(latlng, address = null) {
      // Update the position
      reportPosition = latlng;
      
      // Update coordinate display
      latDisplay.textContent = latlng.lat.toFixed(6);
      lngDisplay.textContent = latlng.lng.toFixed(6);
      
      // If an address was provided, use it
      if (address) {
        locationAddress = address;
        locationInput.value = address;
      } else {
        // Otherwise try to reverse geocode
        locationAddress = null;
        locationInput.value = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
        
        // Try to get the address via reverse geocoding
        L.Control.Geocoder.nominatim().reverse(latlng, map.getZoom(), results => {
          if (results && results.length > 0) {
            locationAddress = results[0].name;
            locationInput.value = locationAddress;
          }
        });
      }
      
      // Add or move temporary marker
      if (tempMarker) {
        map.removeLayer(tempMarker);
      }
      
      tempMarker = L.marker(latlng, {
        icon: L.icon({
          iconUrl: '/icons/location_searching_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        })
      }).addTo(map).bindPopup('Report location').openPopup();
    }
    
    // Hide report form
    cancelBtn.addEventListener('click', () => {
      reportForm.style.display = 'none';
    });
    
    // Locate user
    locateBtn.addEventListener('click', () => {
      map.locate({setView: true, maxZoom: 16, enableHighAccuracy: true});
    });
    
    // Handle location found
    map.on('locationfound', (e) => {
      // Clear existing location markers
      if (currentPositionMarker) {
        map.removeLayer(currentPositionMarker);
      }
      
      if (accuracyCircle) {
        map.removeLayer(accuracyCircle);
      }
      
      // Create a marker with accuracy circle
      currentPositionMarker = L.marker(e.latlng, {
        icon: L.icon({
          iconUrl: '/icons/not_listed_location_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png',
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          popupAnchor: [0, -16]
        })
      }).addTo(map)
        .bindPopup(`You are within ${Math.round(e.accuracy)} meters of this point`).openPopup();
      
      // Add accuracy circle
      accuracyCircle = L.circle(e.latlng, {
        color: '#4a8f5c',
        fillColor: '#bff4cd',
        fillOpacity: 0.2,
        radius: e.accuracy
      }).addTo(map);
      
      // If the report form is open, update the location
      if (reportForm.style.display === 'block') {
        updateReportLocation(e.latlng);
      }
    });
    
    // Handle location error
    map.on('locationerror', (e) => {
      alert("Could not determine your location: " + e.message);
    });
    
    // Submit report
    submitForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      if (!reportPosition) {
        alert("Please allow location access or center the map on the report location.");
        return;
      }
      
      const type = document.getElementById('type').value;
      const count = document.getElementById('count').value;
      const comment = document.getElementById('comment').value;
      const mediaFile = document.getElementById('media').files[0];
      const icon = document.getElementById('icon').value;
      
      const reportData = {
        type,
        count: parseInt(count, 10),
        comment,
        longitude: reportPosition.lng,
        latitude: reportPosition.lat,
        timestamp: Date.now(),
        icon,
        address: locationAddress || locationInput.value
      };
      
      try {
        const formData = new FormData();
        formData.append('report', JSON.stringify(reportData));
        
        if (mediaFile) {
          formData.append('media', mediaFile);
        }
        
        const response = await fetch('/api/reports', {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
          alert("Report submitted successfully!");
          reportForm.style.display = 'none';
          submitForm.reset();
          
          // Add the new report to the map
          addReportToMap({
            id: result.id,
            ...reportData,
            imageUrl: result.imageUrl
          });
        } else {
          alert("Error: " + (result.error || "Failed to submit report"));
        }
      } catch (error) {
        console.error("Error submitting report:", error);
        alert("Failed to submit report. Please try again.");
      }
    });
    
    // Function to add a report to the map
    function addReportToMap(report) {
      // Create marker with the appropriate icon
      const marker = L.marker([report.latitude, report.longitude], {
        icon: L.icon({
          iconUrl: `/icons/${report.icon || 'location_searching_128dp_BFF4CD_FILL0_wght400_GRAD0_opsz48.png'}`,
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          popupAnchor: [0, -16]
        })
      });
      
      // Format date
      const reportDate = new Date(report.timestamp);
      const formattedDate = reportDate.toLocaleDateString() + ' ' + reportDate.toLocaleTimeString();
      
      // Create popup content
      const popupContent = document.createElement('div');
      popupContent.className = 'popup-content';
      
      // Get category label
      const category = reportCategories.find(cat => cat.id === report.type);
      const categoryLabel = category ? category.label : report.type;
      
      popupContent.innerHTML = `
        <h3>${categoryLabel}</h3>
        <div class="meta">Reported: ${formattedDate}</div>
        <div class="meta">Location: ${report.address || `${report.latitude.toFixed(6)}, ${report.longitude.toFixed(6)}`}</div>
        <p>${report.comment || 'No additional details provided.'}</p>
        ${report.count > 1 ? `<div><strong>Count:</strong> ${report.count}</div>` : ''}
        ${report.imageUrl ? `<img src="${report.imageUrl}" alt="Report image">` : ''}
        
        <div class="comments-section">
          <h4>Comments</h4>
          <div class="comments-list" data-report-id="${report.id}">
            <p class="loading-comments">Loading comments...</p>
          </div>
          
          <div class="comment-form">
            <textarea placeholder="Add a comment..." class="comment-input"></textarea>
            <div class="media-upload">
              <input type="file" accept="image/*,video/*" class="comment-media">
            </div>
            <button class="btn comment-submit" data-report-id="${report.id}">Add Comment</button>
          </div>
        </div>
      `;
      
      // Add the popup to the marker
      marker.bindPopup(popupContent);
      
      // Add marker to the reports layer
      marker.addTo(reportsLayer);
      
      // Add event listener for comment submission
      const commentBtn = popupContent.querySelector('.comment-submit');
      if (commentBtn) {
        commentBtn.addEventListener('click', async () => {
          const commentText = popupContent.querySelector('.comment-input').value.trim();
          const commentMedia = popupContent.querySelector('.comment-media').files[0];
          
          if (!commentText && !commentMedia) {
            alert('Please enter a comment or attach media.');
            return;
          }
          
          try {
            const formData = new FormData();
            formData.append('comment', commentText);
            formData.append('reportId', report.id);
            
            if (commentMedia) {
              // Sanitize media if it's an image
              const sanitizedMedia = await securityFeatures.sanitizeMedia(commentMedia);
              formData.append('media', sanitizedMedia);
            }
            
            const response = await fetch('/api/comments', {
              method: 'POST',
              body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
              // Clear the form
              popupContent.querySelector('.comment-input').value = '';
              popupContent.querySelector('.comment-media').value = '';
              
              // Reload comments
              loadComments(report.id);
            } else {
              alert('Failed to post comment: ' + (result.error || 'Unknown error'));
            }
          } catch (error) {
            console.error('Error posting comment:', error);
            alert('Failed to post comment. Please try again.');
          }
        });
      }
      
      // Load comments when popup is opened
      marker.on('popupopen', () => {
        loadComments(report.id);
      });
      
      return marker;
    }
    
    // Function to load comments for a report
    async function loadComments(reportId) {
      const commentsContainer = document.querySelector(`.comments-list[data-report-id="${reportId}"]`);
      if (!commentsContainer) return;
      
      commentsContainer.innerHTML = '<p class="loading-comments">Loading comments...</p>';
      
      try {
        const response = await fetch(`/api/comments/${reportId}`);
        const data = await response.json();
        
        if (data.success && Array.isArray(data.comments)) {
          if (data.comments.length === 0) {
            commentsContainer.innerHTML = '<p>No comments yet. Be the first to comment!</p>';
          } else {
            commentsContainer.innerHTML = '';
            
            data.comments.forEach(comment => {
              const commentDate = new Date(comment.timestamp);
              const formattedDate = commentDate.toLocaleDateString() + ' ' + commentDate.toLocaleTimeString();
              
              const commentElement = document.createElement('div');
              commentElement.className = 'comment-item';
              commentElement.innerHTML = `
                <div class="comment-meta">Posted: ${formattedDate}</div>
                <div class="comment-text">${comment.text || ''}</div>
                ${comment.imageUrl ? `<img src="${comment.imageUrl}" alt="Comment image">` : ''}
              `;
              
              commentsContainer.appendChild(commentElement);
            });
          }
        } else {
          commentsContainer.innerHTML = '<p>Failed to load comments.</p>';
        }
      } catch (error) {
        console.error('Error loading comments:', error);
        commentsContainer.innerHTML = '<p>Failed to load comments. Please try again.</p>';
      }
    }
    
    // Load initial reports
    async function loadReports() {
      try {
        const response = await fetch('/api/reports');
        const data = await response.json();
        
        if (data.success && Array.isArray(data.reports)) {
          data.reports.forEach(report => {
            addReportToMap(report);
          });
        } else {
          console.error('Failed to load reports:', data.error || 'Unknown error');
        }
      } catch (error) {
        console.error('Error loading reports:', error);
      }
    }
    
    // Load initial reports
    loadReports();
    
    // Set up WebSocket for real-time updates
    function setupWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/api/live`;
      
      const socket = new WebSocket(wsUrl);
      
      socket.onopen = () => {
        console.log('WebSocket connection established');
      };
      
      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          if (data.type === 'comment') {
            // Handle new comment - refresh comments if popup for this report is open
            console.log('New comment:', data);
            const openPopup = document.querySelector(`.comments-list[data-report-id="${data.reportId}"]`);
            if (openPopup) {
              loadComments(data.reportId);
            }
          } else {
            // Handle new report
            console.log('New report:', data);
            addReportToMap(data);
          }
        } catch (error) {
          console.error('Error handling WebSocket message:', error);
        }
      };
      
      socket.onclose = () => {
        console.log('WebSocket connection closed, reconnecting...');
        setTimeout(setupWebSocket, 3000);
      };
      
      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        socket.close();
      };
    }
    
    // Initialize WebSocket
    setupWebSocket();
    
    // Language and translation functions
    let currentLanguage = 'en';
    let translations = {};
    
    // Load translations for current language
    async function loadLanguages() {
      try {
        const response = await fetch('/api/translations');
        const data = await response.json();
        
        if (data && data.languages) {
          // Populate language selector
          const languageSelect = document.getElementById('language-select');
          languageSelect.innerHTML = ''; // Clear existing options
          
          data.languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang.code;
            option.textContent = lang.name || lang.code;
            languageSelect.appendChild(option);
          });
          
          // Check for stored language preference
          const storedLang = localStorage.getItem('pigmap-language');
          
          // Set default language (stored preference, browser language, or fallback to English)
          if (storedLang && data.languages.some(l => l.code === storedLang)) {
            languageSelect.value = storedLang;
            currentLanguage = storedLang;
          } else {
            const userLang = navigator.language.split('-')[0];
            if (data.languages.some(l => l.code === userLang)) {
              languageSelect.value = userLang;
              currentLanguage = userLang;
            } else {
              languageSelect.value = 'en';
              currentLanguage = 'en';
            }
          }
          
          // Load translations for default language
          await loadTranslationsForLanguage(currentLanguage);
          
          // Add event listener for language change
          languageSelect.addEventListener('change', async (e) => {
            currentLanguage = e.target.value;
            localStorage.setItem('pigmap-language', currentLanguage);
            await loadTranslationsForLanguage(currentLanguage);
            updateUITranslations();
          });
        }
      } catch (error) {
        console.error("Error loading languages:", error);
      }
    }
    
    async function loadTranslationsForLanguage(langCode) {
      try {
        const response = await fetch(`/api/translations/${langCode}`);
        const data = await response.json();
        translations = data;
        
        // Update UI with new translations
        updateUITranslations();
      } catch (error) {
        console.error(`Error loading translations for ${langCode}:`, error);
        // Fallback to English
        translations = {};
      }
    }
    
    function updateUITranslations() {
      // Update static UI elements
      document.querySelector('.header h1').textContent = translations.appTitle || 'PigMap.org';
      document.getElementById('report-btn').textContent = translations.reportBtn || 'Report Location';
      document.getElementById('locate-btn').textContent = translations.locateBtn || 'Find My Location';
      
      // Update form elements
      document.querySelector('#report-form h2').textContent = translations.reportFormTitle || 'Report Location';
      document.querySelector('label[for="type"]').textContent = (translations.typeLabel || 'Type') + ':';
      document.querySelector('label[for="count"]').textContent = (translations.countLabel || 'How many?') + ':';
      document.querySelector('label[for="comment"]').textContent = (translations.commentLabel || 'Comments') + ':';
      document.querySelector('label[for="location"]').textContent = (translations.locationLabel || 'Location') + ':';
      document.querySelector('label[for="media"]').textContent = (translations.mediaLabel || 'Photo/Video (optional)') + ':';
      document.querySelector('label[for="icon"]').textContent = (translations.iconLabel || 'Icon') + ':';
      
      // Update buttons
      document.getElementById('cancel-btn').textContent = translations.cancelBtn || 'Cancel';
      document.querySelector('#submit-report button[type="submit"]').textContent = translations.submitBtn || 'Submit';
      document.getElementById('update-location-btn').textContent = translations.updateLocationBtn || 'Update Location';
      
      // Update language selector label
      document.querySelector('label[for="language-select"]').textContent = translations.languageLabel || 'Language:';
      
      // Update geocoder placeholder
      if (geocoder && translations.searchPlaceholder) {
        const geocoderInput = document.querySelector('.leaflet-control-geocoder-form input');
        if (geocoderInput) {
          geocoderInput.placeholder = translations.searchPlaceholder;
        }
      }
      
      // Update type options if translations are available
      if (translations.typeOptions) {
        const typeSelect = document.getElementById('type');
        const currentValue = typeSelect.value;
        typeSelect.innerHTML = '';
        
        Object.entries(translations.typeOptions).forEach(([value, label]) => {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          typeSelect.appendChild(option);
        });
        
        // Restore selected value
        typeSelect.value = currentValue;
      }
    }
    
    // Initialize language support
    loadLanguages();
    
    // Dark mode functionality
    function setDarkMode(isDark) {
      if (isDark) {
        document.body.classList.add('dark-mode');
        document.getElementById('dark-mode-icon').textContent = '☀️';
        document.getElementById('dark-mode-label').textContent = 'Light Mode';
        localStorage.setItem('pigmap-dark-mode', 'true');
      } else {
        document.body.classList.remove('dark-mode');
        document.getElementById('dark-mode-icon').textContent = '🌙';
        document.getElementById('dark-mode-label').textContent = 'Dark Mode';
        localStorage.setItem('pigmap-dark-mode', 'false');
      }
    }
    
    // Dark mode toggle event listener
    document.querySelector('.dark-mode-toggle').addEventListener('click', () => {
      const isDarkModeEnabled = document.body.classList.contains('dark-mode');
      setDarkMode(!isDarkModeEnabled);
    });
    
    // Initialize dark mode based on preference (default to dark mode)
    const savedDarkMode = localStorage.getItem('pigmap-dark-mode');
    if (savedDarkMode === null || savedDarkMode === 'true') {
      setDarkMode(true);
    } else {
      setDarkMode(false);
    }
    
    // Initialize security features
    securityFeatures.setupPrivacyMode();
    
    // Populate category select
    function populateCategories() {
      const typeSelect = document.getElementById('type');
      const categoryDescription = document.getElementById('category-description');
      
      // Clear existing options
      typeSelect.innerHTML = '';
      
      // Add each category as an option
      reportCategories.forEach(category => {
        const option = document.createElement('option');
        option.value = category.id;
        option.textContent = category.label;
        typeSelect.appendChild(option);
      });
      
      // Set description for initially selected category
      updateCategoryDescription();
      
      // Update description when selection changes
      typeSelect.addEventListener('change', updateCategoryDescription);
    }
    
    // Update category description based on selection
    function updateCategoryDescription() {
      const typeSelect = document.getElementById('type');
      const categoryDescription = document.getElementById('category-description');
      const selectedCategory = reportCategories.find(cat => cat.id === typeSelect.value);
      
      if (selectedCategory) {
        categoryDescription.textContent = selectedCategory.description;
      } else {
        categoryDescription.textContent = '';
      }
    }
    
    // Initialize category select
    populateCategories();
    
    // Populate icon select with options from categories
    function populateIconSelect() {
      const iconSelect = document.getElementById('icon');
      const iconPreview = document.getElementById('icon-preview');
      
      // Clear existing options
      iconSelect.innerHTML = '';
      iconPreview.innerHTML = '';
      
      // Add each icon as an option
      const uniqueIcons = [...new Set(reportCategories.map(cat => cat.icon))];
      
      uniqueIcons.forEach(icon => {
        // Add to dropdown
        const option = document.createElement('option');
        option.value = icon;
        option.textContent = icon.replace(/_/g, ' ').replace('.png', '');
        iconSelect.appendChild(option);
        
        // Add to visual preview
        const iconOption = document.createElement('div');
        iconOption.className = 'icon-option';
        iconOption.setAttribute('data-icon', icon);
        iconOption.innerHTML = `<img src="/icons/${icon}" alt="${icon}">`;
        iconPreview.appendChild(iconOption);
        
        // Add click handler
        iconOption.addEventListener('click', () => {
          // Update select value
          iconSelect.value = icon;
          
          // Update visual selection
          document.querySelectorAll('.icon-option').forEach(opt => {
            opt.classList.remove('selected');
          });
          iconOption.classList.add('selected');
        });
      });
      
      // Initial selection
      if (uniqueIcons.length > 0) {
        iconSelect.value = uniqueIcons[0];
        document.querySelector(`.icon-option[data-icon="${uniqueIcons[0]}"]`).classList.add('selected');
      }
      
      // Sync dropdown and visual selector
      iconSelect.addEventListener('change', () => {
        const selectedIcon = iconSelect.value;
        document.querySelectorAll('.icon-option').forEach(opt => {
          opt.classList.toggle('selected', opt.getAttribute('data-icon') === selectedIcon);
        });
      });
    }
    
    // Initialize icon select
    populateIconSelect();
    
    // Function to show notifications
    function showNotification(message, type = 'info', duration = 5000) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      
      const container = document.getElementById('notification-container');
      if (!container) {
        const newContainer = document.createElement('div');
        newContainer.id = 'notification-container';
        document.body.appendChild(newContainer);
        newContainer.appendChild(notification);
      } else {
        container.appendChild(notification);
      }
      
      // Remove notification after duration
      setTimeout(() => {
        notification.classList.add('hide');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, duration);
    }
    
    // Show privacy notification when the page loads
    setTimeout(() => {
      showNotification('Enhanced privacy features enabled: metadata removal and automatic data clearing', 'info', 8000);
    }, 1000);
    
    // Dark mode toggle functionality
    const darkModeToggle = document.querySelector('.dark-mode-toggle');
    const darkModeIcon = document.getElementById('dark-mode-icon');
    const darkModeLabel = document.getElementById('dark-mode-label');
    
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      
      // Update icon and label based on dark mode state
      if (document.body.classList.contains('dark-mode')) {
        darkModeIcon.textContent = '☀️';
        darkModeLabel.textContent = 'Light Mode';
      } else {
        darkModeIcon.textContent = '🌙';
        darkModeLabel.textContent = 'Dark Mode';
      }
    });
  </script>
</body>
</html>
